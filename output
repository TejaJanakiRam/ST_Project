[32m23:24:29 (69165) INFO ProjectReader[39m Found 23 of 53 file(s) to be mutated.
[32m23:24:29 (69165) INFO Instrumenter[39m Instrumented 23 source file(s) with 797 mutant(s)
[32m23:24:29 (69165) INFO ConcurrencyTokenProvider[39m Creating 11 test runner process(es).
[32m23:24:30 (69165) INFO BroadcastReporter[39m Detected that current console does not support the "progress" reporter, downgrading to "progress-append-only" reporter
[32m23:24:31 (69165) INFO DryRunExecutor[39m Starting initial test run (mocha test runner with "perTest" coverage analysis). This may take a while.
[32m23:24:31 (69165) INFO DryRunExecutor[39m Initial test run succeeded. Ran 68 tests in 0 seconds (net 72 ms, overhead 96 ms).
Mutation testing 99% (elapsed: <1m, remaining: n/a) 793/797 tested (101 survived, 97 timed out)

All tests
  BellmanFord.test.js
    âœ“ BellmanFord Function Test Case 1 (killed 30)
    ~ BellmanFord Function Test Case 2 (covered 42)
  BreadthFirstSearch.test.js
    âœ“ BreadthFirstSearch should return the visited nodes (killed 34)
  BreadthFirstShortestPath.test.js
    âœ“ BreadthFirstShortestPath should return the visited nodes (killed 23)
  BubbleSort.test.js
    âœ“ bubbleSort should sort arrays correctly (killed 17)
    âœ“ alternativeBubbleSort should sort arrays correctly (killed 13)
  ConnectedComponents.test.js
    âœ“ GraphUnweightedUndirectedAdjacencyList should add nodes correctly (killed 2)
    âœ“ GraphUnweightedUndirectedAdjacencyList should add edges correctly (killed 8)
    âœ“ GraphUnweightedUndirectedAdjacencyList should correctly identify connected components (killed 15)
    ~ GraphUnweightedUndirectedAdjacencyList should handle an empty graph (covered 3)
  CountingSort.test.js
    âœ“ countingSort Function should sort the array [3, 0, 2, 5, 4, 1] to [0, 1, 2, 3, 4, 5] (killed 17)
    âœ“ countingSort Function should sort the array [6, 4, 2, 1, 3, 5] to [1, 2, 3, 4, 5, 6] (killed 3)
    ~ countingSort Function should sort the array [11, 14, 12, 15, 16, 13] to [11, 12, 13, 14, 15, 16] (covered 29)
    ~ countingSort Function should sort the array [13, 18, 2, 15, 43, 11] to [2, 11, 13, 15, 18, 43] (covered 29)
  DepthFirstSearchRecursive.test.js
    âœ“ GraphUnweightedUndirected should add nodes correctly (killed 4)
    âœ“ GraphUnweightedUndirected should add edges correctly (killed 2)
    âœ“ GraphUnweightedUndirected should perform DFS correctly and find a node (killed 22)
    âœ“ GraphUnweightedUndirected should perform DFS correctly and not find a node (killed 8)
    ~ GraphUnweightedUndirected should handle an empty graph for DFS (covered 7)
  Dijkstra.test.js
    âœ“ Dijkstra's Algorithm should find the shortest path and distances in the graph (killed 53)
  DijkstraSmallestPath.test.js
    âœ“ solve should find the shortest path and distances in the graph (killed 17)
  FloydWarshall.test.js
    âœ“ Floyd-Warshall Algorithm should find the shortest distances between nodes in the graph (killed 20)
  InsertionSort.test.js
    âœ“ insertionSortAlternativeImplementation should sort an array using insertionSort (killed 15)
    âœ“ insertionSortAlternativeImplementation should sort an array using insertionSortAlternativeImplementation (killed 16)
    ~ insertionSortAlternativeImplementation should handle an empty array for insertionSort (covered 4)
    ~ insertionSortAlternativeImplementation should handle an empty array for insertionSortAlternativeImplementation (covered 5)
    ~ insertionSortAlternativeImplementation should handle an array with a single element for insertionSort (covered 4)
    ~ insertionSortAlternativeImplementation should handle an array with a single element for insertionSortAlternativeImplementation (covered 5)
    ~ insertionSortAlternativeImplementation expects to work with empty array (covered 5)
    ~ insertionSortAlternativeImplementation expects to return input array when array.length is less than 2 (covered 5)
    âœ“ insertionSortAlternativeImplementation expects to return array sorted in ascending order (killed 1)
  Kosaraju.test.js
    âœ“ Kosaraju Function Test Case 1 (killed 39)
    ~ Kosaraju Function Test Case 2 (covered 46)
  KruskalMST.test.js
    âœ“ Kruskal's Algorithm should generate a Minimum Spanning Tree (MST) for a graph (killed 37)
  MergeSort.test.js
    âœ“ merge should merge arrays correctly (killed 9)
    âœ“ MergeSort should work for empty arrays (killed 1)
    âœ“ MergeSort should sort arrays correctly (killed 5)
  NumberOfIslands.test.js
    âœ“ Number of Islands should count three islands in the graph (killed 36)
    ~ Number of Islands should count one island in the graph (covered 45)
    ~ Number of Islands should count zero islands in the graph (covered 15)
  Queue.test.js
    ~ Testing the Queue DS Testing enqueue method (covered 10)
    ~ Testing the Queue DS Testing length after enqueue (covered 1)
    âœ“ Testing the Queue DS Testing peekFirst & peekLast methods (killed 4)
    âœ“ Testing the Queue DS Testing toArray method (killed 3)
    ~ Testing the Queue DS Testing dequeue method (covered 15)
    ~ Testing the Queue DS Testing length after dequeue (covered 1)
    âœ“ Testing the Queue DS Testing isEmpty method (killed 5)
  QuickSelectSearch.test.js
    âœ“ quickSelectSearch should throw an error for invalid arguments (killed 7)
  QuickSort.test.js
    âœ“ QuickSort should work for empty arrays (killed 1)
    âœ“ QuickSort should sort arrays correctly (killed 11)
  QuickSortRecursive.test.js
    âœ“ QuickSortRecursive | Partition In Place Method Expectedly, throw some error if we pass a non-array input (killed 5)
    âœ“ QuickSortRecursive | Partition In Place Method Expectedly, the quickSort method will sort the unsorted list in ascending order (killed 16)
    ~ QuickSortRecursive | Partition In Place Method Expectedly, the quickSort method will arrange the list of character values in dictionary order. (covered 26)
  RadixSort.test.js
    âœ“ Radix Sort should sort the array [4, 3, 2, 1] to [1, 2, 3, 4] (killed 26)
    ~ Radix Sort should handle an empty array and return [] (covered 33)
    ~ Radix Sort should sort the array [14, 16, 10, 12] to [10, 12, 14, 16] (covered 48)
    âœ“ Radix Sort should handle when RADIX<1 (killed 5)
  SelectionSort.test.js
    âœ“ selectionSort expects to return the array sorted in ascending order (killed 24)
    âœ“ selectionSort expects to throw if it is not a valid array (killed 3)
    âœ“ selectionSort expects to throw if one of the elements in the array is not a number (killed 3)
  SimplifiedWiggleSort.test.js
    âœ“ simplified wiggle sort simplified wiggle sort for chars (killed 23)
    âœ“ simplified wiggle sort wiggle sort with duplicates, even array (killed 9)
    âœ“ simplified wiggle sort wiggle sort with duplicates, odd array (killed 2)
    ~ simplified wiggle sort simplified wiggle sort which leads to equal values next to each other (covered 65)

[NoCoverage] BlockStatement
src/BellmanFord.js:33:58
-       if (dis[x] !== Infinity && dis[x] + weight < dis[y]) {
-         return null;
-       }
+       if (dis[x] !== Infinity && dis[x] + weight < dis[y]) {}

[Survived] EqualityOperator
src/BellmanFord.js:21:19
-     for (let i = 0; i < V - 1; i++) {
+     for (let i = 0; i <= V - 1; i++) {
Tests ran:
    BellmanFord Function Test Case 1
    BellmanFord Function Test Case 2


[Survived] ArithmeticOperator
src/BellmanFord.js:21:23
-     for (let i = 0; i < V - 1; i++) {
+     for (let i = 0; i < V + 1; i++) {
Tests ran:
    BellmanFord Function Test Case 1
    BellmanFord Function Test Case 2


[Survived] EqualityOperator
src/BellmanFord.js:23:11
-         if (dis[graph[j][0]] + graph[j][2] < dis[graph[j][1]]) {
+         if (dis[graph[j][0]] + graph[j][2] <= dis[graph[j][1]]) {
Tests ran:
    BellmanFord Function Test Case 1
    BellmanFord Function Test Case 2


[Survived] ConditionalExpression
src/BellmanFord.js:29:19
-     for (let i = 0; i < E; i++) {
+     for (let i = 0; false; i++) {
Tests ran:
    BellmanFord Function Test Case 1
    BellmanFord Function Test Case 2


[Survived] EqualityOperator
src/BellmanFord.js:29:19
-     for (let i = 0; i < E; i++) {
+     for (let i = 0; i >= E; i++) {
Tests ran:
    BellmanFord Function Test Case 1
    BellmanFord Function Test Case 2


[Survived] BlockStatement
src/BellmanFord.js:29:31
-     for (let i = 0; i < E; i++) {
-       const x = graph[i][0];
-       const y = graph[i][1];
-       const weight = graph[i][2];
-       if (dis[x] !== Infinity && dis[x] + weight < dis[y]) {
-         return null;
-       }
-     }
+     for (let i = 0; i < E; i++) {}
Tests ran:
    BellmanFord Function Test Case 1
    BellmanFord Function Test Case 2


[Survived] ConditionalExpression
src/BellmanFord.js:33:9
-       if (dis[x] !== Infinity && dis[x] + weight < dis[y]) {
+       if (false) {
Tests ran:
    BellmanFord Function Test Case 1
    BellmanFord Function Test Case 2


[Survived] ConditionalExpression
src/BellmanFord.js:33:9
-       if (dis[x] !== Infinity && dis[x] + weight < dis[y]) {
+       if (true && dis[x] + weight < dis[y]) {
Tests ran:
    BellmanFord Function Test Case 1
    BellmanFord Function Test Case 2


[Survived] EqualityOperator
src/BellmanFord.js:33:9
-       if (dis[x] !== Infinity && dis[x] + weight < dis[y]) {
+       if (dis[x] === Infinity && dis[x] + weight < dis[y]) {
Tests ran:
    BellmanFord Function Test Case 1
    BellmanFord Function Test Case 2


[Survived] EqualityOperator
src/BellmanFord.js:37:19
-     for (let i = 0; i < V; i++) {
+     for (let i = 0; i <= V; i++) {
Tests ran:
    BellmanFord Function Test Case 1
    BellmanFord Function Test Case 2


[Survived] EqualityOperator
src/BubbleSort.js:5:24
-     for (let i = length; i > 0; i--) {
+     for (let i = length; i >= 0; i--) {
Tests ran:
    bubbleSort should sort arrays correctly


[Survived] UpdateOperator
src/BubbleSort.js:5:31
-     for (let i = length; i > 0; i--) {
+     for (let i = length; i > 0; i++) {
Tests ran:
    bubbleSort should sort arrays correctly


[Survived] BooleanLiteral
src/BubbleSort.js:7:15
-       noSwaps = true;
+       noSwaps = false;
Tests ran:
    bubbleSort should sort arrays correctly


[Survived] EqualityOperator
src/BubbleSort.js:9:21
-       for (let j = 0; j < i - 1; j++) {
+       for (let j = 0; j <= i - 1; j++) {
Tests ran:
    bubbleSort should sort arrays correctly


[Survived] ArithmeticOperator
src/BubbleSort.js:9:25
-       for (let j = 0; j < i - 1; j++) {
+       for (let j = 0; j < i + 1; j++) {
Tests ran:
    bubbleSort should sort arrays correctly


[Survived] EqualityOperator
src/BubbleSort.js:11:11
-         if (items[j] > items[j + 1]) {
+         if (items[j] >= items[j + 1]) {
Tests ran:
    bubbleSort should sort arrays correctly


[Survived] ConditionalExpression
src/BubbleSort.js:17:9
-       if (noSwaps) {
+       if (false) {
Tests ran:
    bubbleSort should sort arrays correctly
    if (noSwaps) {
      break;
    }

[Survived] BlockStatement
src/BubbleSort.js:17:18
-       if (noSwaps) {
-         break;
-       }
+       if (noSwaps) {}
Tests ran:
    bubbleSort should sort arrays correctly


[Survived] EqualityOperator
src/BubbleSort.js:33:21
-       for (let i = 0; i < arr.length - 1; i++) {
+       for (let i = 0; i <= arr.length - 1; i++) {
Tests ran:
    alternativeBubbleSort should sort arrays correctly


[Survived] ArithmeticOperator
src/BubbleSort.js:33:25
-       for (let i = 0; i < arr.length - 1; i++) {
+       for (let i = 0; i < arr.length + 1; i++) {
Tests ran:
    alternativeBubbleSort should sort arrays correctly


[Survived] EqualityOperator
src/BubbleSort.js:34:11
-         if (arr[i] > arr[i + 1]) {
+         if (arr[i] >= arr[i + 1]) {
Tests ran:
    alternativeBubbleSort should sort arrays correctly


[Survived] ConditionalExpression
src/ConnectedComponents.js:17:9
-       if (!(node2 in this.connections)) {
+       if (true) {
Tests ran:
    GraphUnweightedUndirectedAdjacencyList should add edges correctly
    GraphUnweightedUndirectedAdjacencyList should correctly identify connected components


[Survived] ArrayDeclaration
src/CountingSort.js:3:15
-     const res = [];
+     const res = ["Stryker was here"];
Tests ran:
    countingSort Function should sort the array [3, 0, 2, 5, 4, 1] to [0, 1, 2, 3, 4, 5]
    countingSort Function should sort the array [6, 4, 2, 1, 3, 5] to [1, 2, 3, 4, 5, 6]
    countingSort Function should sort the array [11, 14, 12, 15, 16, 13] to [11, 12, 13, 14, 15, 16]
  and 1 more test!


[Survived] ArithmeticOperator
src/CountingSort.js:5:27
-     const count = new Array(max - min + 1).fill(0);
+     const count = new Array(max + min + 1).fill(0);
Tests ran:
    countingSort Function should sort the array [3, 0, 2, 5, 4, 1] to [0, 1, 2, 3, 4, 5]
    countingSort Function should sort the array [6, 4, 2, 1, 3, 5] to [1, 2, 3, 4, 5, 6]
    countingSort Function should sort the array [11, 14, 12, 15, 16, 13] to [11, 12, 13, 14, 15, 16]
  and 1 more test!


[Survived] EqualityOperator
src/CountingSort.js:7:19
-     for (let i = 0; i < arr.length; i++) {
+     for (let i = 0; i <= arr.length; i++) {
Tests ran:
    countingSort Function should sort the array [3, 0, 2, 5, 4, 1] to [0, 1, 2, 3, 4, 5]
    countingSort Function should sort the array [6, 4, 2, 1, 3, 5] to [1, 2, 3, 4, 5, 6]
    countingSort Function should sort the array [11, 14, 12, 15, 16, 13] to [11, 12, 13, 14, 15, 16]
  and 1 more test!


[Survived] ArithmeticOperator
src/CountingSort.js:16:16
-     for (let i = arr.length - 1; i >= 0; i--) {
+     for (let i = arr.length + 1; i >= 0; i--) {
Tests ran:
    countingSort Function should sort the array [3, 0, 2, 5, 4, 1] to [0, 1, 2, 3, 4, 5]
    countingSort Function should sort the array [6, 4, 2, 1, 3, 5] to [1, 2, 3, 4, 5, 6]
    countingSort Function should sort the array [11, 14, 12, 15, 16, 13] to [11, 12, 13, 14, 15, 16]
  and 1 more test!


[Survived] UpdateOperator
src/CountingSort.js:18:5
-       count[arr[i] - min]--;
+       count[arr[i] - min]++;
Tests ran:
    countingSort Function should sort the array [3, 0, 2, 5, 4, 1] to [0, 1, 2, 3, 4, 5]
    countingSort Function should sort the array [6, 4, 2, 1, 3, 5] to [1, 2, 3, 4, 5, 6]
    countingSort Function should sort the array [11, 14, 12, 15, 16, 13] to [11, 12, 13, 14, 15, 16]
  and 1 more test!


[Survived] EqualityOperator
src/Dijkstra.js:5:19
-     for (let i = 0; i < V; i++) {
+     for (let i = 0; i <= V; i++) {
Tests ran:
    Dijkstra's Algorithm should find the shortest path and distances in the graph


[Survived] ArrayDeclaration
src/Dijkstra.js:6:18
-       adjList.push([]);
+       adjList.push(["Stryker was here"]);
Tests ran:
    Dijkstra's Algorithm should find the shortest path and distances in the graph


[Survived] EqualityOperator
src/Dijkstra.js:18:19
-     for (let i = 0; i < V; i++) dist.push([10000, -1]);
+     for (let i = 0; i <= V; i++) dist.push([10000, -1]);
Tests ran:
    Dijkstra's Algorithm should find the shortest path and distances in the graph


[Survived] UnaryOperator
src/Dijkstra.js:18:49
-     for (let i = 0; i < V; i++) dist.push([10000, -1]);
+     for (let i = 0; i < V; i++) dist.push([10000, +1]);
Tests ran:
    Dijkstra's Algorithm should find the shortest path and distances in the graph


[Survived] EqualityOperator
src/Dijkstra.js:21:19
-     for (let i = 0; i < V - 1; i++) {
+     for (let i = 0; i <= V - 1; i++) {
Tests ran:
    Dijkstra's Algorithm should find the shortest path and distances in the graph


[Survived] EqualityOperator
src/Dijkstra.js:23:21
-       for (let j = 0; j < V; j++) {
+       for (let j = 0; j <= V; j++) {
Tests ran:
    Dijkstra's Algorithm should find the shortest path and distances in the graph


[Survived] EqualityOperator
src/Dijkstra.js:25:26
-           if (mn === -1 || dist[j][0] < dist[mn][0]) mn = j;
+           if (mn === -1 || dist[j][0] <= dist[mn][0]) mn = j;
Tests ran:
    Dijkstra's Algorithm should find the shortest path and distances in the graph


[Survived] ConditionalExpression
src/Dijkstra.js:32:11
-         if (vis[edge[0]] === 0 && dist[edge[0]][0] > dist[mn][0] + edge[1]) {
+         if (true && dist[edge[0]][0] > dist[mn][0] + edge[1]) {
Tests ran:
    Dijkstra's Algorithm should find the shortest path and distances in the graph


[Survived] EqualityOperator
src/Dijkstra.js:32:33
-         if (vis[edge[0]] === 0 && dist[edge[0]][0] > dist[mn][0] + edge[1]) {
+         if (vis[edge[0]] === 0 && dist[edge[0]][0] >= dist[mn][0] + edge[1]) {
Tests ran:
    Dijkstra's Algorithm should find the shortest path and distances in the graph


[Survived] EqualityOperator
src/DijkstraSmallestPath.js:23:13
-           if (d < dist) {
+           if (d <= dist) {
Tests ran:
    solve should find the shortest path and distances in the graph


[Survived] EqualityOperator
src/FloydWarshall.js:7:23
-         for (let j = 0; j < n; j++) {
+         for (let j = 0; j <= n; j++) {
Tests ran:
    Floyd-Warshall Algorithm should find the shortest distances between nodes in the graph


[Survived] EqualityOperator
src/FloydWarshall.js:8:13
-           if (dist[i][j] > dist[i][k] + dist[k][j]) {
+           if (dist[i][j] >= dist[i][k] + dist[k][j]) {
Tests ran:
    Floyd-Warshall Algorithm should find the shortest distances between nodes in the graph


[Survived] ConditionalExpression
src/InsertionSort.js:7:21
-       for (j = i - 1; j >= 0 && unsortedList[j] > tmp; j--) {
+       for (j = i - 1; true && unsortedList[j] > tmp; j--) {
Tests ran:
    insertionSortAlternativeImplementation should sort an array using insertionSort


[Survived] EqualityOperator
src/InsertionSort.js:7:31
-       for (j = i - 1; j >= 0 && unsortedList[j] > tmp; j--) {
+       for (j = i - 1; j >= 0 && unsortedList[j] >= tmp; j--) {
Tests ran:
    insertionSortAlternativeImplementation should sort an array using insertionSort


[Survived] ConditionalExpression
src/InsertionSort.js:27:7
-     if (length < 2) return array;
+     if (false) return array;
Tests ran:
    insertionSortAlternativeImplementation should sort an array using insertionSortAlternativeImplementation
    insertionSortAlternativeImplementation should handle an empty array for insertionSortAlternativeImplementation
    insertionSortAlternativeImplementation should handle an array with a single element for insertionSortAlternativeImplementation
  and 3 more tests!


[Survived] ConditionalExpression
src/InsertionSort.js:36:12
-       while (j >= 0 && array[j] > currentItem) {
+       while (true && array[j] > currentItem) {
Tests ran:
    insertionSortAlternativeImplementation should sort an array using insertionSortAlternativeImplementation
    insertionSortAlternativeImplementation expects to return array sorted in ascending order


[Survived] EqualityOperator
src/InsertionSort.js:36:22
-       while (j >= 0 && array[j] > currentItem) {
+       while (j >= 0 && array[j] >= currentItem) {
Tests ran:
    insertionSortAlternativeImplementation should sort an array using insertionSortAlternativeImplementation
    insertionSortAlternativeImplementation expects to return array sorted in ascending order


[Survived] LogicalOperator
src/Kosaraju.js:22:9
-       if (!(node1 in this.connections) || !(node1 in this.reverseConnections)) {
+       if (!(node1 in this.connections) && !(node1 in this.reverseConnections)) {
Tests ran:
    Kosaraju Function Test Case 1
    Kosaraju Function Test Case 2


[Survived] LogicalOperator
src/Kosaraju.js:25:9
-       if (!(node2 in this.connections) || !(node2 in this.reverseConnections)) {
+       if (!(node2 in this.connections) && !(node2 in this.reverseConnections)) {
Tests ran:
    Kosaraju Function Test Case 1
    Kosaraju Function Test Case 2


[Survived] ConditionalExpression
src/KruskalMST.js:24:9
-       if (this.map[x] !== this.map[x].parent) {
+       if (false) {
Tests ran:
    Kruskal's Algorithm should generate a Minimum Spanning Tree (MST) for a graph


[Survived] BlockStatement
src/KruskalMST.js:24:45
-       if (this.map[x] !== this.map[x].parent) {
-         this.map[x].parent = this.findSet(this.map[x].parent.key);
-       }
+       if (this.map[x] !== this.map[x].parent) {}
Tests ran:
    Kruskal's Algorithm should generate a Minimum Spanning Tree (MST) for a graph


[Survived] BlockStatement
src/KruskalMST.js:30:15
-     union(x, y) {
-       // Function to merge 2 disjoint sets
-       this.link(this.findSet(x), this.findSet(y));
-     }
+     union(x, y) {}
Tests ran:
    Kruskal's Algorithm should generate a Minimum Spanning Tree (MST) for a graph


[Survived] BlockStatement
src/KruskalMST.js:35:14
-     link(x, y) {
-       // Helper function for union operation
-       if (x.rank > y.rank) {
-         y.parent = x;
-       } else {
-         x.parent = y;
-         if (x.rank === y.rank) {
-           y.rank += 1;
-         }
-       }
-     }
+     link(x, y) {}
Tests ran:
    Kruskal's Algorithm should generate a Minimum Spanning Tree (MST) for a graph


[Survived] ConditionalExpression
src/KruskalMST.js:37:9
-       if (x.rank > y.rank) {
+       if (true) {
Tests ran:
    Kruskal's Algorithm should generate a Minimum Spanning Tree (MST) for a graph


[Survived] EqualityOperator
src/KruskalMST.js:37:9
-       if (x.rank > y.rank) {
+       if (x.rank <= y.rank) {
Tests ran:
    Kruskal's Algorithm should generate a Minimum Spanning Tree (MST) for a graph


[Survived] BlockStatement
src/KruskalMST.js:37:26
-       if (x.rank > y.rank) {
-         y.parent = x;
-       } else {
+       if (x.rank > y.rank) {} else {
Tests ran:
    Kruskal's Algorithm should generate a Minimum Spanning Tree (MST) for a graph


[Survived] ConditionalExpression
src/KruskalMST.js:37:9
-       if (x.rank > y.rank) {
+       if (false) {
Tests ran:
    Kruskal's Algorithm should generate a Minimum Spanning Tree (MST) for a graph


[Survived] BlockStatement
src/KruskalMST.js:39:12
-       } else {
-         x.parent = y;
-         if (x.rank === y.rank) {
-           y.rank += 1;
-         }
-       }
+       } else {}
Tests ran:
    Kruskal's Algorithm should generate a Minimum Spanning Tree (MST) for a graph


[Survived] EqualityOperator
src/KruskalMST.js:37:9
-       if (x.rank > y.rank) {
+       if (x.rank >= y.rank) {
Tests ran:
    Kruskal's Algorithm should generate a Minimum Spanning Tree (MST) for a graph


[Survived] ConditionalExpression
src/KruskalMST.js:41:11
-         if (x.rank === y.rank) {
+         if (true) {
Tests ran:
    Kruskal's Algorithm should generate a Minimum Spanning Tree (MST) for a graph


[Survived] EqualityOperator
src/KruskalMST.js:41:11
-         if (x.rank === y.rank) {
+         if (x.rank !== y.rank) {
Tests ran:
    Kruskal's Algorithm should generate a Minimum Spanning Tree (MST) for a graph


[Survived] ConditionalExpression
src/KruskalMST.js:41:11
-         if (x.rank === y.rank) {
+         if (false) {
Tests ran:
    Kruskal's Algorithm should generate a Minimum Spanning Tree (MST) for a graph


[Survived] AssignmentOperator
src/KruskalMST.js:42:9
-           y.rank += 1;
+           y.rank -= 1;
Tests ran:
    Kruskal's Algorithm should generate a Minimum Spanning Tree (MST) for a graph


[Survived] BlockStatement
src/KruskalMST.js:41:30
-         if (x.rank === y.rank) {
-           y.rank += 1;
-         }
+         if (x.rank === y.rank) {}
Tests ran:
    Kruskal's Algorithm should generate a Minimum Spanning Tree (MST) for a graph


[Survived] ConditionalExpression
src/KruskalMST.js:81:13
-           if (!seen.has(`${start} ${end}`)) {
+           if (true) {
Tests ran:
    Kruskal's Algorithm should generate a Minimum Spanning Tree (MST) for a graph


[Survived] StringLiteral
src/KruskalMST.js:81:23
-           if (!seen.has(`${start} ${end}`)) {
+           if (!seen.has(``)) {
Tests ran:
    Kruskal's Algorithm should generate a Minimum Spanning Tree (MST) for a graph


[Survived] StringLiteral
src/KruskalMST.js:82:20
-             seen.add(`${end} ${start}`);
+             seen.add(``);
Tests ran:
    Kruskal's Algorithm should generate a Minimum Spanning Tree (MST) for a graph


[Survived] ConditionalExpression
src/KruskalMST.js:98:11
-         if (disjointSet.findSet(u) !== disjointSet.findSet(v)) {
+         if (true) {
Tests ran:
    Kruskal's Algorithm should generate a Minimum Spanning Tree (MST) for a graph


[Survived] EqualityOperator
src/MergeSort.js:13:10
-     while (i < list1.length && j < list2.length) {
+     while (i <= list1.length && j < list2.length) {
Tests ran:
    merge should merge arrays correctly
    MergeSort should sort arrays correctly


[Survived] ConditionalExpression
src/MergeSort.js:13:10
-     while (i < list1.length && j < list2.length) {
+     while (true && j < list2.length) {
Tests ran:
    merge should merge arrays correctly
    MergeSort should sort arrays correctly


[Survived] EqualityOperator
src/MergeSort.js:14:9
-       if (list1[i] < list2[j]) {
+       if (list1[i] <= list2[j]) {
Tests ran:
    merge should merge arrays correctly
    MergeSort should sort arrays correctly


[Survived] ConditionalExpression
src/NumberOfIslands.js:6:20
-       if (row < 0 || col < 0) return; // Off the map above or left
+       if (row < 0 || false) return; // Off the map above or left
Tests ran:
    Number of Islands should count three islands in the graph
    Number of Islands should count one island in the graph


[Survived] EqualityOperator
src/NumberOfIslands.js:7:33
-       if (row >= matrix.length || col >= matrix[row].length) return; // Off the map below or right
+       if (row >= matrix.length || col > matrix[row].length) return; // Off the map below or right
Tests ran:
    Number of Islands should count three islands in the graph
    Number of Islands should count one island in the graph


[Survived] ConditionalExpression
src/NumberOfIslands.js:7:33
-       if (row >= matrix.length || col >= matrix[row].length) return; // Off the map below or right
+       if (row >= matrix.length || false) return; // Off the map below or right
Tests ran:
    Number of Islands should count three islands in the graph
    Number of Islands should count one island in the graph


[Survived] StringLiteral
src/NumberOfIslands.js:12:24
-       matrix[row][col] = "0";
+       matrix[row][col] = "";
Tests ran:
    Number of Islands should count three islands in the graph
    Number of Islands should count one island in the graph


[Survived] ArithmeticOperator
src/NumberOfIslands.js:15:11
-       flood(row - 1, col); // Up
+       flood(row + 1, col); // Up
Tests ran:
    Number of Islands should count three islands in the graph
    Number of Islands should count one island in the graph


[Survived] ArithmeticOperator
src/NumberOfIslands.js:17:16
-       flood(row, col - 1); // Left
+       flood(row, col + 1); // Left
Tests ran:
    Number of Islands should count three islands in the graph
    Number of Islands should count one island in the graph


[Survived] EqualityOperator
src/NumberOfIslands.js:21:23
-       for (let col = 0; col < matrix[row].length; col += 1) {
+       for (let col = 0; col <= matrix[row].length; col += 1) {
Tests ran:
    Number of Islands should count three islands in the graph
    Number of Islands should count one island in the graph
    Number of Islands should count zero islands in the graph


[Survived] LogicalOperator
src/Queue.js:24:9
-       if (!this.head && !this.tail) {
+       if (!this.head || !this.tail) {
Tests ran:
    BreadthFirstSearch should return the visited nodes
    BreadthFirstShortestPath should return the visited nodes
    Testing the Queue DS Testing enqueue method
  and 1 more test!


[Survived] BlockStatement
src/Queue.js:40:25
-       if (this.isEmpty()) {
-         throw new Error("Empty");
-       }
+       if (this.isEmpty()) {}
Tests ran:
    Testing the Queue DS Testing isEmpty method


[Survived] ConditionalExpression
src/Queue.js:40:9
-       if (this.isEmpty()) {
+       if (false) {
Tests ran:
    BreadthFirstSearch should return the visited nodes
    BreadthFirstShortestPath should return the visited nodes
    Testing the Queue DS Testing dequeue method
  and 1 more test!


[Survived] EqualityOperator
src/QuickSelectSearch.js:2:17
-     if (!array || array.length <= k) {
+     if (!array || array.length < k) {
Tests ran:
    quickSelectSearch should throw an error for invalid arguments
    simplified wiggle sort simplified wiggle sort for chars
    simplified wiggle sort wiggle sort with duplicates, even array
  and 2 more tests!


[Survived] EqualityOperator
src/QuickSort.js:11:7
-     if (length <= 1) {
+     if (length < 1) {
Tests ran:
    QuickSort should work for empty arrays
    QuickSort should sort arrays correctly


[Survived] EqualityOperator
src/QuickSort.js:19:9
-       if (items[i] > PIVOT) {
+       if (items[i] >= PIVOT) {
Tests ran:
    QuickSort should sort arrays correctly


[Survived] EqualityOperator
src/QuickSortRecursive.js:11:7
-     if (low < high) {
+     if (low <= high) {
Tests ran:
    QuickSortRecursive | Partition In Place Method Expectedly, the quickSort method will sort the unsorted list in ascending order
    QuickSortRecursive | Partition In Place Method Expectedly, the quickSort method will arrange the list of character values in dictionary order.


[Survived] ArithmeticOperator
src/QuickSortRecursive.js:31:34
-     for (let index = low; index <= high - 1; index++) {
+     for (let index = low; index <= high + 1; index++) {
Tests ran:
    QuickSortRecursive | Partition In Place Method Expectedly, the quickSort method will sort the unsorted list in ascending order
    QuickSortRecursive | Partition In Place Method Expectedly, the quickSort method will arrange the list of character values in dictionary order.


[Survived] EqualityOperator
src/QuickSortRecursive.js:32:9
-       if (partitionList[index] < pivot) {
+       if (partitionList[index] <= pivot) {
Tests ran:
    QuickSortRecursive | Partition In Place Method Expectedly, the quickSort method will sort the unsorted list in ascending order
    QuickSortRecursive | Partition In Place Method Expectedly, the quickSort method will arrange the list of character values in dictionary order.


[Survived] ConditionalExpression
src/RadixSort.js:3:7
-     if (RADIX === undefined || RADIX < 1) {
+     if (true) {
Tests ran:
    Radix Sort should sort the array [4, 3, 2, 1] to [1, 2, 3, 4]
    Radix Sort should handle an empty array and return []
    Radix Sort should sort the array [14, 16, 10, 12] to [10, 12, 14, 16]
  and 1 more test!


[Survived] ConditionalExpression
src/RadixSort.js:3:7
-     if (RADIX === undefined || RADIX < 1) {
+     if (false || RADIX < 1) {
Tests ran:
    Radix Sort should sort the array [4, 3, 2, 1] to [1, 2, 3, 4]
    Radix Sort should handle an empty array and return []
    Radix Sort should sort the array [14, 16, 10, 12] to [10, 12, 14, 16]
  and 1 more test!


[Survived] EqualityOperator
src/RadixSort.js:3:7
-     if (RADIX === undefined || RADIX < 1) {
+     if (RADIX !== undefined || RADIX < 1) {
Tests ran:
    Radix Sort should sort the array [4, 3, 2, 1] to [1, 2, 3, 4]
    Radix Sort should handle an empty array and return []
    Radix Sort should sort the array [14, 16, 10, 12] to [10, 12, 14, 16]
  and 1 more test!


[Survived] EqualityOperator
src/RadixSort.js:3:30
-     if (RADIX === undefined || RADIX < 1) {
+     if (RADIX === undefined || RADIX <= 1) {
Tests ran:
    Radix Sort should sort the array [4, 3, 2, 1] to [1, 2, 3, 4]
    Radix Sort should handle an empty array and return []
    Radix Sort should sort the array [14, 16, 10, 12] to [10, 12, 14, 16]
  and 1 more test!


[Survived] EqualityOperator
src/RadixSort.js:14:21
-       for (let i = 0; i < RADIX; i++) {
+       for (let i = 0; i <= RADIX; i++) {
Tests ran:
    Radix Sort should sort the array [4, 3, 2, 1] to [1, 2, 3, 4]
    Radix Sort should handle an empty array and return []
    Radix Sort should sort the array [14, 16, 10, 12] to [10, 12, 14, 16]
  and 1 more test!


[Survived] ConditionalExpression
src/RadixSort.js:21:11
-         if (maxLength && tmp > 0) {
+         if (false) {
Tests ran:
    Radix Sort should sort the array [4, 3, 2, 1] to [1, 2, 3, 4]
    Radix Sort should sort the array [14, 16, 10, 12] to [10, 12, 14, 16]
    Radix Sort should handle when RADIX<1


[Survived] EqualityOperator
src/RadixSort.js:21:24
-         if (maxLength && tmp > 0) {
+         if (maxLength && tmp <= 0) {
Tests ran:
    Radix Sort should sort the array [4, 3, 2, 1] to [1, 2, 3, 4]
    Radix Sort should sort the array [14, 16, 10, 12] to [10, 12, 14, 16]
    Radix Sort should handle when RADIX<1


[Survived] BooleanLiteral
src/RadixSort.js:22:21
-           maxLength = false;
+           maxLength = true;
Tests ran:
    Radix Sort should sort the array [4, 3, 2, 1] to [1, 2, 3, 4]
    Radix Sort should sort the array [14, 16, 10, 12] to [10, 12, 14, 16]
    Radix Sort should handle when RADIX<1


[Survived] BlockStatement
src/RadixSort.js:21:33
-         if (maxLength && tmp > 0) {
-           maxLength = false;
-         }
+         if (maxLength && tmp > 0) {}
Tests ran:
    Radix Sort should sort the array [4, 3, 2, 1] to [1, 2, 3, 4]
    Radix Sort should sort the array [14, 16, 10, 12] to [10, 12, 14, 16]
    Radix Sort should handle when RADIX<1


[Survived] EqualityOperator
src/SelectionSort.js:7:19
-     for (let i = 0; i < length - 1; i++) {
+     for (let i = 0; i <= length - 1; i++) {
Tests ran:
    selectionSort expects to return the array sorted in ascending order
    selectionSort expects to throw if one of the elements in the array is not a number


[Survived] EqualityOperator
src/SelectionSort.js:13:25
-       for (let j = i + 1; j < length; j++) {
+       for (let j = i + 1; j <= length; j++) {
Tests ran:
    selectionSort expects to return the array sorted in ascending order
    selectionSort expects to throw if one of the elements in the array is not a number


[Survived] EqualityOperator
src/SelectionSort.js:15:11
-         if (items[j] < items[min]) {
+         if (items[j] <= items[min]) {
Tests ran:
    selectionSort expects to return the array sorted in ascending order
    selectionSort expects to throw if one of the elements in the array is not a number


[Survived] ConditionalExpression
src/SelectionSort.js:20:9
-       if (min !== i) {
+       if (true) {
Tests ran:
    selectionSort expects to return the array sorted in ascending order
    selectionSort expects to throw if one of the elements in the array is not a number


[Survived] ArithmeticOperator
src/SimplifiedWiggleSort.js:6:30
-     median = median[Math.floor(arr.length / 2.0)];
+     median = median[Math.floor(arr.length * 2.0)];
Tests ran:
    simplified wiggle sort simplified wiggle sort for chars
    simplified wiggle sort wiggle sort with duplicates, even array
    simplified wiggle sort wiggle sort with duplicates, odd array
  and 1 more test!


[Survived] ArrayDeclaration
src/SimplifiedWiggleSort.js:8:18
-     const sorted = new Array(arr.length);
+     const sorted = new Array();
Tests ran:
    simplified wiggle sort simplified wiggle sort for chars
    simplified wiggle sort wiggle sort with duplicates, even array
    simplified wiggle sort wiggle sort with duplicates, odd array
  and 1 more test!


[Survived] EqualityOperator
src/SimplifiedWiggleSort.js:13:19
-     for (let i = 0; i < arr.length; i++) {
+     for (let i = 0; i <= arr.length; i++) {
Tests ran:
    simplified wiggle sort simplified wiggle sort for chars
    simplified wiggle sort wiggle sort with duplicates, even array
    simplified wiggle sort wiggle sort with duplicates, odd array
  and 1 more test!


[Survived] ConditionalExpression
src/SimplifiedWiggleSort.js:14:9
-       if (arr[i] > median) {
+       if (false) {
Tests ran:
    simplified wiggle sort simplified wiggle sort for chars
    simplified wiggle sort wiggle sort with duplicates, even array
    simplified wiggle sort wiggle sort with duplicates, odd array
  and 1 more test!


Ran 1.11 tests per mutant on average.
------------------------------|---------|----------|-----------|------------|----------|----------|
File                          | % score | # killed | # timeout | # survived | # no cov | # errors |
------------------------------|---------|----------|-----------|------------|----------|----------|
All files                     |   87.20 |      594 |       101 |        101 |        1 |        0 |
 BellmanFord.js               |   74.42 |       30 |         2 |         10 |        1 |        0 |
 BreadthFirstSearch.js        |  100.00 |       10 |         3 |          0 |        0 |        0 |
 BreadthFirstShortestPath.js  |  100.00 |       23 |         3 |          0 |        0 |        0 |
 BubbleSort.js                |   76.60 |       30 |         6 |         11 |        0 |        0 |
 ConnectedComponents.js       |   96.55 |       25 |         3 |          1 |        0 |        0 |
 CountingSort.js              |   82.76 |       20 |         4 |          5 |        0 |        0 |
 DepthFirstSearchIterative.js |  100.00 |       18 |         2 |          0 |        0 |        0 |
 DepthFirstSearchRecursive.js |  100.00 |       18 |         1 |          0 |        0 |        0 |
 Dijkstra.js                  |   86.15 |       53 |         3 |          9 |        0 |        0 |
 DijkstraSmallestPath.js      |   95.24 |       17 |         3 |          1 |        0 |        0 |
 FloydWarshall.js             |   91.30 |       20 |         1 |          2 |        0 |        0 |
 InsertionSort.js             |   88.10 |       32 |         5 |          5 |        0 |        0 |
 Kosaraju.js                  |   95.65 |       39 |         5 |          2 |        0 |        0 |
 KruskalMST.js                |   67.80 |       37 |         3 |         19 |        0 |        0 |
 MergeSort.js                 |   89.66 |       15 |        11 |          3 |        0 |        0 |
 NumberOfIslands.js           |   84.44 |       36 |         2 |          7 |        0 |        0 |
 Queue.js                     |   92.50 |       36 |         1 |          3 |        0 |        0 |
 QuickSelectSearch.js         |   97.62 |       19 |        22 |          1 |        0 |        0 |
 QuickSort.js                 |   90.00 |       12 |         6 |          2 |        0 |        0 |
 QuickSortRecursive.js        |   89.29 |       21 |         4 |          3 |        0 |        0 |
 RadixSort.js                 |   81.63 |       31 |         9 |          9 |        0 |        0 |
 SelectionSort.js             |   88.57 |       30 |         1 |          4 |        0 |        0 |
 SimplifiedWiggleSort.js      |   85.19 |       22 |         1 |          4 |        0 |        0 |
------------------------------|---------|----------|-----------|------------|----------|----------|
[32m23:24:42 (69165) INFO HtmlReporter[39m Your report can be found at: file:///home/pushkar/Desktop/ST_PROJ/ST_Project/reports/mutation/mutation.html
[32m23:24:42 (69165) INFO MutationTestExecutor[39m Done in 13 seconds.
